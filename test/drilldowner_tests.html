<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DrillDowner QUnit Test Suite</title>

    <!-- QUnit CSS and JS -->
    <link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-2.19.4.css">
    <script src="https://code.jquery.com/qunit/qunit-2.19.4.js"></script>

    <!-- jQuery (only for QUnit test helpers, not for DrillDowner) -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>


    <!-- DrillDowner files - these would need to be included in your test environment -->
    <link href="../src/drilldowner.css" rel="stylesheet"  type="text/css"/>
    <script src="../src/DrillDowner.js"></script>
</head>
<body>
<div id="qunit"></div>
<div id="qunit-fixture">
    <!-- Test containers -->
    <div id="test-container"></div>
    <div id="test-controls"></div>
    <div id="test-azbar"></div>
</div>

<script>
    // Test data
    const testData = [
        {p:"Zeta", c:"Naranja", w:"W2", rolls:32, quantity:72, unidades:"Kg", sale:false, slow:false, superslow:false, customFlag:true, status:"pending", priority:3},
        {p:"Alpha", c:"Rojo", w:"W1", rolls:12, quantity:122, unidades:"Kg", sale:true, slow:false, superslow:false, customFlag:true, status:"completed", priority:1},
        {p:"Alpha", c:"Rojo", w:"W2", rolls:2, quantity:22, unidades:"Kg", sale:false, superslow:false, status:"active", priority:2},
        {p:"Alpha", c:"Azul", w:"W1", rolls:3, quantity:10, unidades:"Kg", sale:false, slow:false, superslow:true, customFlag:false, status:"pending", priority:1},
        {p:"Beta", c:"Verde", w:"W1", rolls:4, quantity:30, unidades:"m", sale:false, slow:false, superslow:false, customFlag:true, status:"completed", priority:2},
        {p:"Gamma", c:"Rojo", w:"W2", rolls:1, quantity:15, unidades:"m", sale:true, slow:false, superslow:false, customFlag:false, status:"active", priority:3},
        {p:"Delta", c:"Amarillo", w:"W3", rolls:7, quantity:54, unidades:"Kg", sale:false, slow:true, superslow:true, customFlag:false, status:"pending", priority:1},
        {p:"Zeta", c:"Naranja", w:"W1", rolls:3, quantity:70, unidades:"Kg", sale:false, slow:false, superslow:false, customFlag:true, status:"completed", priority:2},
        {p:"Zeta", c:"Naranja2", w:"W1", rolls:3, quantity:70, unidades:"m", sale:false, slow:false, superslow:false, customFlag:true, status:"completed", priority:2},
    ];

    const testColProperties = {
        "p": {
            label: "Producto",
            key: "product",
            labelClass: "header_producto"
        },
        "c": {
            label: "Color",
            key: "color",
            labelClass: "header_color"
        },
        "w": {
            label: "Almac√©n",
            key: "warehouse",
            labelClass: "header_almacen"
        },
        "rolls": {
            label: "Rollos",
            decimals: 0,
            class: "lupa_num"
        },
        "quantity": {
            label: "Cantidad",
            decimals: 2,
            subTotalBy: "unidades",
            class: "lupa_num"
        },
        "unidades": {
            label: "Kg/m",
            togglesUp: true,
            class: "",
            formatter: function(value) {
                return value || "";
            }
        },
        "slow": {
            label: "Lento",
            togglesUp: true,
            class: "lupa_status_slow",
            formatter: function(value) {
                return value ? "‚óè" : "";
            }
        },
        "sale": {
            label: "En Oferta",
            togglesUp: true,
            class: "lupa_status_sale"
        },
        "superslow": {
            label: "Muy Lento",
            togglesUp: true,
            class: "lupa_status_superslow"
        },
        "status": {
            label: "Estado",
            class: "",
            formatter: function(value) {
                const statusMap = {
                    "pending": "‚è≥ Pendiente",
                    "active": "üîÑ Activo",
                    "completed": "‚úÖ Completado"
                };
                return statusMap[value] || value;
            }
        },
        "priority": {
            label: "Prioridad",
            class: "",
            formatter: function(value) {
                const stars = "‚òÖ".repeat(value);
                const color = value === 1 ? 'color: red' : value === 2 ? 'color: orange' : 'color: gray';
                return `<span style="${color}">${stars}</span>`;
            }
        }
    };

    // QUnit Tests
    QUnit.module('DrillDowner Initialization', function() {
        QUnit.test('Basic initialization with minimal options', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"]
            });

            assert.ok(drillDowner instanceof DrillDowner, 'DrillDowner instance created');
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table is rendered');
            assert.ok(drillDowner.options.idPrefix.length > 0, 'ID prefix is generated');

            drillDowner.destroy();
        });

        QUnit.test('Initialization with all options', function(assert) {
            const container = '#test-container';
            const controls = '#test-controls';
            const azbar = '#test-azbar';

            document.querySelector(container).innerHTML = '';
            document.querySelector(controls).innerHTML = '';
            document.querySelector(azbar).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status", "priority"],
                totals: ["rolls", "quantity"],
                colProperties: testColProperties,
                azBarSelector: azbar,
                controlsSelector: controls
            });

            assert.ok(drillDowner instanceof DrillDowner, 'DrillDowner instance created');
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table is rendered');
            assert.ok(document.querySelector(controls + ' .drillDowner_controls_container'), 'Controls are rendered');
            assert.ok(document.querySelector(azbar + ' .drillDowner_az_link'), 'AZ bar is rendered');

            drillDowner.destroy();
        });

        QUnit.test('Initialization with empty data', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, [], {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"]
            });

            assert.ok(drillDowner instanceof DrillDowner, 'DrillDowner instance created with empty data');
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table is rendered even with empty data');

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner Table Rendering', function() {
        QUnit.test('Table structure is correct', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c"],
                columns: ["status"],
                totals: ["rolls"],
                colProperties: testColProperties
            });

            const table = document.querySelector(container + ' table.drillDowner_table');
            assert.ok(table, 'Table exists');

            const thead = table.querySelector('thead');
            assert.ok(thead, 'Table header exists');

            const tbody = table.querySelector('tbody');
            assert.ok(tbody, 'Table body exists');

            const headerCount = thead.querySelectorAll('th').length;
            assert.equal(headerCount, 3, 'Correct number of headers (Item + 1 total + 1 column)');

            drillDowner.destroy();
        });

        QUnit.test('Drill icons are present at appropriate levels', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c"],
                columns: ["status"],
                totals: ["rolls"]
            });

            const level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]');
            const level1Rows = document.querySelectorAll(container + ' tr[data-level="1"]');

            assert.ok(level0Rows.length > 0, 'Level 0 rows exist');
            assert.ok(level1Rows.length > 0, 'Level 1 rows exist');

            // Level 0 should have drill icons (can drill to level 1)
            let level0DrillIcons = 0;
            level0Rows.forEach(row => {
                level0DrillIcons += row.querySelectorAll('.drillDowner_drill_icon').length;
            });
            assert.ok(level0DrillIcons > 0, 'Level 0 rows have drill icons');

            // Level 1 should not have drill icons (last level)
            let level1DrillIcons = 0;
            level1Rows.forEach(row => {
                level1DrillIcons += row.querySelectorAll('.drillDowner_drill_icon').length;
            });
            assert.equal(level1DrillIcons, 0, 'Level 1 rows do not have drill icons');

            drillDowner.destroy();
        });

        QUnit.test('Totals are calculated correctly', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: [],
                totals: ["rolls"],
                colProperties: testColProperties
            });

            // Check that totals are displayed in the table
            const table = document.querySelector(container + ' table.drillDowner_table');
            const totalCells = table.querySelectorAll('td.drillDowner_num');

            assert.ok(totalCells.length > 0, 'Total cells are present');

            // Verify at least one total is a number
            let foundNumericTotal = false;
            totalCells.forEach(cell => {
                const text = cell.textContent.trim();
                if (!isNaN(parseFloat(text))) {
                    foundNumericTotal = true;
                }
            });
            assert.ok(foundNumericTotal, 'At least one numeric total found');

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner Collapse/Expand Functionality', function() {
        QUnit.test('collapseToLevel works correctly', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Initially collapsed to level 0
            let visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            let level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]').length;
            assert.equal(visibleRows, level0Rows, 'Initially only level 0 rows are visible');

            // Expand to level 1
            drillDowner.collapseToLevel(1);
            visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]').length;
            const level1Rows = document.querySelectorAll(container + ' tr[data-level="1"]').length;
            assert.equal(visibleRows, level0Rows + level1Rows, 'Level 0 and 1 rows are visible');

            // Collapse back to level 0
            drillDowner.collapseToLevel(0);
            visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]').length;
            assert.equal(visibleRows, level0Rows, 'Back to only level 0 rows visible');

            drillDowner.destroy();
        });

        QUnit.test('collapseAll and expandAll work correctly', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Test expandAll
            drillDowner.expandAll();
            const allVisibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            const totalRows = document.querySelectorAll(container + ' tbody tr').length;
            assert.equal(allVisibleRows, totalRows, 'expandAll shows all rows');

            // Test collapseAll
            drillDowner.collapseAll();
            const visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            const level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]').length;
            assert.equal(visibleRows, level0Rows, 'collapseAll shows only level 0 rows');

            drillDowner.destroy();
        });

        QUnit.test('Individual drill click functionality', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Find the first drill icon
            const firstDrillIcon = document.querySelector(container + ' .drillDowner_drill_icon');
            assert.ok(firstDrillIcon, 'Drill icon found');
            assert.ok(firstDrillIcon.classList.contains('drillDowner_drill_collapsed'), 'Initially collapsed');

            // Simulate click
            firstDrillIcon.click();

            // Check if it expanded
            assert.ok(firstDrillIcon.classList.contains('drillDowner_drill_expanded'), 'Icon is now expanded');

            // Click again to collapse
            firstDrillIcon.click();
            assert.ok(firstDrillIcon.classList.contains('drillDowner_drill_collapsed'), 'Icon is collapsed again');

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner Controls', function() {
        QUnit.test('Controls render with breadcrumbs', function(assert) {
            const container = '#test-container';
            const controls = '#test-controls';
            document.querySelector(container).innerHTML = '';
            document.querySelector(controls).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"],
                colProperties: testColProperties,
                controlsSelector: controls
            });

            const breadcrumbs = document.querySelectorAll(controls + ' .drillDowner_breadcrumb_item');
            assert.equal(breadcrumbs.length, 3, 'Three breadcrumb items for three group levels');

            const arrows = document.querySelectorAll(controls + ' .drillDowner_breadcrumb_arrow');
            assert.equal(arrows.length, 2, 'Two arrows between three levels');

            drillDowner.destroy();
        });

        QUnit.test('Breadcrumb clicks work', function(assert) {
            const container = '#test-container';
            const controls = '#test-controls';
            document.querySelector(container).innerHTML = '';
            document.querySelector(controls).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"],
                controlsSelector: controls
            });

            // Click on level 1 breadcrumb
            const level1Breadcrumb = document.querySelector(controls + ' .drillDowner_breadcrumb_item[data-level="1"]');
            assert.ok(level1Breadcrumb, 'Level 1 breadcrumb found');

            level1Breadcrumb.click();

            // Check if view expanded to level 1
            const visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            const level0And1Rows = document.querySelectorAll(container + ' tr[data-level="0"], ' + container + ' tr[data-level="1"]').length;
            assert.ok(visibleRows >= level0And1Rows, 'Breadcrumb click expanded view');

            drillDowner.destroy();
        });

        QUnit.test('Group order selector works', function(assert) {
            const container = '#test-container';
            const controls = '#test-controls';
            document.querySelector(container).innerHTML = '';
            document.querySelector(controls).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"],
                colProperties: testColProperties,
                controlsSelector: controls
            });

            const select = document.querySelector(controls + ' select');
            if (select) {
                // Change to a different grouping order
                select.value = '1,0,2';
                const event = new Event('change');
                select.dispatchEvent(event);

                // Verify the order changed
                assert.deepEqual(drillDowner.options.groupOrder, ['c', 'p', 'w'], 'Group order changed correctly');
            } else {
                assert.ok(true, 'No group selector (acceptable for some configurations)');
            }

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner AZ Bar', function() {
        QUnit.test('AZ bar renders correctly', function(assert) {
            const container = '#test-container';
            const azbar = '#test-azbar';
            document.querySelector(container).innerHTML = '';
            document.querySelector(azbar).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"],
                azBarSelector: azbar
            });

            const azLinks = document.querySelectorAll(azbar + ' .drillDowner_az_link');
            const azDimmed = document.querySelectorAll(azbar + ' .drillDowner_az_dimmed');

            assert.ok(azLinks.length > 0, 'Active AZ links found');
            assert.ok(azDimmed.length > 0, 'Dimmed AZ letters found');
            assert.equal(azLinks.length + azDimmed.length, 26, 'All 26 letters present');

            drillDowner.destroy();
        });

        QUnit.test('AZ bar shows correct active letters', function(assert) {
            const container = '#test-container';
            const azbar = '#test-azbar';
            document.querySelector(container).innerHTML = '';
            document.querySelector(azbar).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"],
                azBarSelector: azbar
            });

            // Check that letters corresponding to our test data are active
            const expectedActiveLetters = ['A', 'B', 'D', 'G', 'Z']; // Alpha, Beta, Delta, Gamma, Zeta

            expectedActiveLetters.forEach(letter => {
                const links = Array.from(document.querySelectorAll(azbar + ' .drillDowner_az_link'))
                    .filter(link => link.textContent === letter);
                assert.ok(links.length > 0, `Letter ${letter} is active in AZ bar`);
            });

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner Column Properties', function() {
        QUnit.test('Column labels are applied correctly', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"],
                colProperties: testColProperties,
                showGrandTotals: false // Disable grand totals for cleaner header text testing
            });

            const headers = document.querySelectorAll(container + ' thead th');
            const headerTexts = Array.from(headers).map(header => header.textContent);

            assert.ok(headerTexts.includes('Rollos'), 'Custom label for rolls column applied');
            assert.ok(headerTexts.includes('Estado'), 'Custom label for status column applied');

            drillDowner.destroy();
        });

        QUnit.test('Column formatters work correctly', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c"],
                columns: ["status", "priority"],
                totals: [],
                colProperties: testColProperties
            });

            drillDowner.expandAll();

            // Check for formatted status values
            const statusCells = Array.from(document.querySelectorAll(container + ' tbody tr[data-level="1"] td'))
                .filter(cell => cell.textContent.includes('‚è≥') || cell.textContent.includes('üîÑ') || cell.textContent.includes('‚úÖ'));
            assert.ok(statusCells.length > 0, 'Status formatter applied correctly');

            // Check for formatted priority values (stars)
            const priorityCells = Array.from(document.querySelectorAll(container + ' tbody tr[data-level="1"] td'))
                .filter(cell => cell.textContent.includes('‚òÖ'));
            assert.ok(priorityCells.length > 0, 'Priority formatter applied correctly');

            drillDowner.destroy();
        });

        QUnit.test('togglesUp property works correctly', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["unidades", "slow"],
                totals: [],
                colProperties: testColProperties
            });

            // Check that togglesUp columns show combined values
            const unidadesCells = Array.from(document.querySelectorAll(container + ' tbody td'))
                .filter(cell => cell.textContent.includes('Kg') || cell.textContent.includes('m'));
            assert.ok(unidadesCells.length > 0, 'togglesUp columns show aggregated values');

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner Edge Cases', function() {
        QUnit.test('Handles invalid collapse levels', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Test negative level
            drillDowner.collapseToLevel(-1);
            let visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            let level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]').length;
            assert.equal(visibleRows, level0Rows, 'Negative level defaults to 0');

            // Test level beyond available
            drillDowner.collapseToLevel(10);
            const allRows = document.querySelectorAll(container + ' tbody tr').length;
            visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            assert.equal(visibleRows, allRows, 'Excessive level shows all rows');

            // Test null/undefined level
            drillDowner.collapseToLevel(null);
            visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]').length;
            assert.equal(visibleRows, level0Rows, 'Null level defaults to 0');

            drillDowner.destroy();
        });

        QUnit.test('Handles missing column properties gracefully', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["nonexistent"],
                columns: ["alsononexistent"],
                totals: ["rolls"]
            });

            assert.ok(drillDowner instanceof DrillDowner, 'DrillDowner handles missing columns');
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table still renders');

            drillDowner.destroy();
        });

        QUnit.test('Destroy method cleans up properly', function(assert) {
            const container = '#test-container';
            const controls = '#test-controls';
            const azbar = '#test-azbar';

            document.querySelector(container).innerHTML = '';
            document.querySelector(controls).innerHTML = '';
            document.querySelector(azbar).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c"],
                columns: ["status"],
                totals: ["rolls"],
                controlsSelector: controls,
                azBarSelector: azbar
            });

            // Verify elements exist before destroy
            assert.ok(document.querySelector(container + ' table'), 'Table exists before destroy');
            assert.ok(document.querySelector(controls).children.length > 0, 'Controls exist before destroy');
            assert.ok(document.querySelector(azbar).children.length > 0, 'AZ bar exists before destroy');

            drillDowner.destroy();

            // Verify cleanup
            assert.equal(document.querySelector(container).children.length, 0, 'Container is empty after destroy');
            assert.equal(document.querySelector(controls).children.length, 0, 'Controls are empty after destroy');
            assert.equal(document.querySelector(azbar).children.length, 0, 'AZ bar is empty after destroy');
        });
    });

    QUnit.module('DrillDowner Static Methods', function() {
        QUnit.test('formatNumber works correctly', function(assert) {
            assert.equal(DrillDowner.formatNumber(1234.567, 2), '1,234.57', 'Number formatted with 2 decimals');
            assert.equal(DrillDowner.formatNumber(1000, 0), '1,000', 'Number formatted with 0 decimals');
            assert.equal(DrillDowner.formatNumber('invalid', 2), 'invalid', 'Invalid number returned as-is');
            assert.equal(DrillDowner.formatNumber(0, 1), '0.0', 'Zero formatted correctly');
        });
    });

    QUnit.module('DrillDowner Grand Totals', function() {
        QUnit.test('Grand totals are calculated correctly for simple totals', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"],
                colProperties: testColProperties,
                showGrandTotals: true
            });

            // Check that grand totals object exists and has correct values
            assert.ok(drillDowner.grandTotals, 'Grand totals object exists');
            assert.ok(drillDowner.grandTotals.hasOwnProperty('rolls'), 'Grand totals contains rolls');

            // Calculate expected total manually
            const expectedRollsTotal = testData.reduce((sum, row) => sum + (row.rolls || 0), 0);
            assert.equal(drillDowner.grandTotals.rolls, expectedRollsTotal, 'Grand total for rolls is correct');

            drillDowner.destroy();
        });

        QUnit.test('Grand totals are calculated correctly for subTotalBy columns', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["quantity"],
                colProperties: testColProperties,
                showGrandTotals: true
            });

            // Check that grand totals for subTotalBy columns are objects
            assert.ok(drillDowner.grandTotals.quantity, 'Grand totals contains quantity');
            assert.equal(typeof drillDowner.grandTotals.quantity, 'object', 'Quantity grand total is an object (subtotals)');

            // Check that it has the expected unit keys
            assert.ok(drillDowner.grandTotals.quantity.hasOwnProperty('Kg'), 'Grand totals has Kg subtotal');
            assert.ok(drillDowner.grandTotals.quantity.hasOwnProperty('m'), 'Grand totals has m subtotal');

            // Calculate expected subtotals manually
            const expectedKgTotal = testData.filter(row => row.unidades === 'Kg').reduce((sum, row) => sum + (row.quantity || 0), 0);
            const expectedMTotal = testData.filter(row => row.unidades === 'm').reduce((sum, row) => sum + (row.quantity || 0), 0);

            assert.equal(drillDowner.grandTotals.quantity.Kg, expectedKgTotal, 'Kg subtotal is correct');
            assert.equal(drillDowner.grandTotals.quantity.m, expectedMTotal, 'm subtotal is correct');

            drillDowner.destroy();
        });

        QUnit.test('Table header shows grand totals when enabled', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls", "quantity"],
                colProperties: testColProperties,
                showGrandTotals: true
            });

            const table = document.querySelector(container + ' table.drillDowner_table');
            const headers = table.querySelectorAll('thead th');

            // Check that headers contain grand total information
            let foundRollsGrandTotal = false;
            let foundQuantityGrandTotal = false;

            headers.forEach(header => {
                const headerHTML = header.innerHTML;
                if (headerHTML.includes('Rollos') && headerHTML.includes('<small>')) {
                    foundRollsGrandTotal = true;
                }
                if (headerHTML.includes('Cantidad') && headerHTML.includes('<small>')) {
                    foundQuantityGrandTotal = true;
                }
            });

            assert.ok(foundRollsGrandTotal, 'Rolls header contains grand total');
            assert.ok(foundQuantityGrandTotal, 'Quantity header contains grand total');

            drillDowner.destroy();
        });

        QUnit.test('Table footer (tfoot) is created when grand totals are enabled', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls", "quantity"],
                colProperties: testColProperties,
                showGrandTotals: true
            });

            const table = document.querySelector(container + ' table.drillDowner_table');
            const tfoot = table.querySelector('tfoot');

            assert.ok(tfoot, 'Table footer exists when grand totals enabled');

            const tfootRow = tfoot.querySelector('tr');
            assert.ok(tfootRow, 'Footer row exists');

            const tfootCells = tfootRow.querySelectorAll('td');
            assert.ok(tfootCells.length > 0, 'Footer cells exist');

            // Check that first cell says "Total"
            const firstCellText = tfootCells[0].textContent;
            assert.ok(firstCellText.includes('Total'), 'First footer cell contains "Total"');

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner Data Modification Tests', function() {
        QUnit.test('Adding items to data array and calling render()', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            // Create a copy of test data to modify
            const modifiableData = [...testData.slice(0, 3)]; // Start with just 3 items

            const drillDowner = new DrillDowner(container, modifiableData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Count initial rows
            const initialRowCount = document.querySelectorAll(container + ' tbody tr').length;
            assert.ok(initialRowCount > 0, 'Initial rows are rendered');

            // Add new items to the data array
            const newItems = [
                {p:"Epsilon", c:"Morado", w:"W4", rolls:5, quantity:45, unidades:"Kg", status:"pending"},
                {p:"Omega", c:"Negro", w:"W5", rolls:8, quantity:60, unidades:"m", status:"completed"}
            ];

            modifiableData.push(...newItems);

            // Re-render the table
            drillDowner.render();

            // Count rows after adding items
            const newRowCount = document.querySelectorAll(container + ' tbody tr').length;
            assert.ok(newRowCount > initialRowCount, 'New rows added after render()');

            // Verify new data is present
            const rowTexts = Array.from(document.querySelectorAll(container + ' tbody tr')).map(row => row.textContent);
            assert.ok(rowTexts.some(text => text.includes('Epsilon')), 'New item "Epsilon" is present');
            assert.ok(rowTexts.some(text => text.includes('Omega')), 'New item "Omega" is present');

            drillDowner.destroy();
        });

        QUnit.test('Removing items from data array and calling render()', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            // Create a copy of test data to modify
            const modifiableData = [...testData];

            const drillDowner = new DrillDowner(container, modifiableData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Count initial rows and check for "Beta" presence
            const initialRowCount = document.querySelectorAll(container + ' tbody tr').length;
            const initialRowTexts = Array.from(document.querySelectorAll(container + ' tbody tr')).map(row => row.textContent);
            assert.ok(initialRowTexts.some(text => text.includes('Beta')), 'Item "Beta" is initially present');

            // Remove items with p="Beta" from the data array
            const betaIndex = modifiableData.findIndex(item => item.p === "Beta");
            if (betaIndex !== -1) {
                modifiableData.splice(betaIndex, 1);
            }

            // Re-render the table
            drillDowner.render();

            // Check that "Beta" is no longer present
            const newRowTexts = Array.from(document.querySelectorAll(container + ' tbody tr')).map(row => row.textContent);
            assert.notOk(newRowTexts.some(text => text.includes('Beta')), 'Item "Beta" was removed');

            // Count rows after removing items
            const newRowCount = document.querySelectorAll(container + ' tbody tr').length;
            assert.ok(newRowCount < initialRowCount, 'Row count decreased after removing items');

            drillDowner.destroy();
        });

        QUnit.test('Modifying items in data array and calling render()', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            // Create a copy of test data to modify
            const modifiableData = [...testData];

            const drillDowner = new DrillDowner(container, modifiableData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Find and modify an item (change Alpha to MODIFIED_ALPHA)
            const alphaItem = modifiableData.find(item => item.p === "Alpha");
            if (alphaItem) {
                alphaItem.p = "MODIFIED_ALPHA";
                alphaItem.rolls = 999; // Also modify a numeric value
            }

            // Re-render the table
            drillDowner.render();

            // Check that the modified item appears with new values
            const rowTexts = Array.from(document.querySelectorAll(container + ' tbody tr')).map(row => row.textContent);
            assert.ok(rowTexts.some(text => text.includes('MODIFIED_ALPHA')), 'Modified item name appears');

            // Check that the total was updated
            const totalCells = document.querySelectorAll(container + ' td.drillDowner_num');
            let found999 = false;
            totalCells.forEach(cell => {
                if (cell.textContent.includes('999')) {
                    found999 = true;
                }
            });
            assert.ok(found999, 'Modified numeric value (999) appears in totals');

            drillDowner.destroy();
        });

        QUnit.test('Changing options after initialization and calling render()', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"],
                colProperties: testColProperties
            });

            // Initially only one grouping level
            assert.equal(drillDowner.options.groupOrder.length, 1, 'Initially one grouping level');

            // Change grouping order
            drillDowner.options.groupOrder = ["p", "c"];

            // Add a new column
            drillDowner.options.columns = ["status", "priority"];


            // Re-render
            drillDowner.render();

            // Verify changes took effect
            assert.equal(drillDowner.options.groupOrder.length, 2, 'Now has two grouping levels');

            // Expand to see the new structure
            drillDowner.expandAll();

            // Check for level 1 rows (should exist now with the new grouping)
            const level1Rows = document.querySelectorAll(container + ' tr[data-level="1"]');
            assert.ok(level1Rows.length > 0, 'Level 1 rows exist after changing groupOrder');

            // Check for priority column (should be visible now)
            const headerTexts = Array.from(document.querySelectorAll(container + ' thead th')).map(th => th.textContent);

            assert.ok(headerTexts.some(text => text.includes('Prioridad')), 'New column "priority" is visible');

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner API Method Tests', function() {
        QUnit.test('Direct test for collapseToLevel method', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Test level 0 (default)
            drillDowner.collapseToLevel(0);
            let visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            let level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]').length;
            assert.equal(visibleRows, level0Rows, 'Level 0 shows only top-level rows');

            // Test level 1
            drillDowner.collapseToLevel(1);
            visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            let level0And1Rows = document.querySelectorAll(container + ' tr[data-level="0"], ' + container + ' tr[data-level="1"]').length;
            assert.equal(visibleRows, level0And1Rows, 'Level 1 shows level 0 and 1 rows');

            // Test level 2
            drillDowner.collapseToLevel(2);
            visibleRows = Array.from(document.querySelectorAll(container + ' tbody tr')).filter(row => 
                window.getComputedStyle(row).display !== 'none').length;
            let allLevelRows = document.querySelectorAll(container + ' tbody tr').length;
            assert.equal(visibleRows, allLevelRows, 'Level 2 shows all rows');

            drillDowner.destroy();
        });

        QUnit.test('Direct test for changeGroupOrder method', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Initial order is p -> c
            assert.deepEqual(drillDowner.options.groupOrder, ["p", "c"], 'Initial group order is ["p", "c"]');

            // Change to c -> p
            drillDowner.changeGroupOrder(["c", "p"]);

            // Verify order changed
            assert.deepEqual(drillDowner.options.groupOrder, ["c", "p"], 'Group order changed to ["c", "p"]');

            // Check that the table structure reflects the new order
            // First level should now be color (c) instead of product (p)
            const firstLevelLabels = Array.from(document.querySelectorAll(container + ' tr[data-level="0"] td:first-child')).map(td => td.textContent);

            // Check if any of the first level labels contain color names
            const containsColorNames = firstLevelLabels.some(label => 
                ["Rojo", "Azul", "Verde", "Amarillo", "Naranja", "Naranja2"].some(color => label.includes(color))
            );

            assert.ok(containsColorNames, 'First level now shows colors instead of products');

            drillDowner.destroy();
        });

        QUnit.test('Direct test for render method', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Modify the DOM directly to simulate changes
            const table = document.querySelector(container + ' table');
            table.setAttribute('data-test-attr', 'original-value');

            // Call render
            drillDowner.render();

            // Check that the table was completely re-rendered (attribute should be gone)
            const newTable = document.querySelector(container + ' table');
            assert.notOk(newTable.hasAttribute('data-test-attr'), 'Table was completely re-rendered');

            drillDowner.destroy();
        });

        QUnit.test('Direct test for getTable method', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Get the table
            const table = drillDowner.getTable();

            // Verify it's the correct element
            assert.ok(table instanceof HTMLElement, 'getTable returns an HTML element');
            assert.ok(table.classList.contains('drillDowner_table'), 'Returned element has drillDowner_table class');

            drillDowner.destroy();
        });

        QUnit.test('Direct test for destroy method', function(assert) {
            const container = '#test-container';
            const controls = '#test-controls';
            const azbar = '#test-azbar';

            document.querySelector(container).innerHTML = '';
            document.querySelector(controls).innerHTML = '';
            document.querySelector(azbar).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p"],
                columns: ["status"],
                totals: ["rolls"],
                controlsSelector: controls,
                azBarSelector: azbar
            });

            // Verify elements exist
            assert.ok(document.querySelector(container + ' table'), 'Table exists');
            assert.ok(document.querySelector(controls).children.length > 0, 'Controls exist');
            assert.ok(document.querySelector(azbar).children.length > 0, 'AZ bar exists');

            // Call destroy
            drillDowner.destroy();

            // Verify elements are removed
            assert.notOk(document.querySelector(container + ' table'), 'Table is removed');
            assert.equal(document.querySelector(controls).children.length, 0, 'Controls are empty');
            assert.equal(document.querySelector(azbar).children.length, 0, 'AZ bar is empty');
        });

        QUnit.test('Method chaining (if supported)', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            const drillDowner = new DrillDowner(container, testData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Test if methods return 'this' for chaining
            // If they don't, this will throw an error
            try {
                const result = drillDowner.collapseAll().expandAll().collapseToLevel(1);
                assert.equal(result, drillDowner, 'Methods return this for chaining');
                assert.ok(true, 'Method chaining works');
            } catch (e) {
                assert.ok(false, 'Method chaining is not supported: ' + e.message);
                console.log('Note: Method chaining is not currently implemented in DrillDowner');
            }

            drillDowner.destroy();
        });
    });

    QUnit.module('DrillDowner Edge Case Tests', function() {
        QUnit.test('Test with empty strings in data', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            // Create data with empty strings
            const emptyStringData = [
                {p:"", c:"Rojo", w:"W1", rolls:10, quantity:100, unidades:"Kg", status:"pending"},
                {p:"Alpha", c:"", w:"W2", rolls:20, quantity:200, unidades:"m", status:"active"},
                {p:"Beta", c:"Verde", w:"", rolls:30, quantity:300, unidades:"Kg", status:"completed"}
            ];

            const drillDowner = new DrillDowner(container, emptyStringData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Check that the table renders without errors
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table renders with empty strings');

            // Check that empty string groups are created
            // const rowTexts = Array.from(document.querySelectorAll(container + ' tbody tr')).map(row => row.textContent);

            // Expand to see all rows
            drillDowner.expandAll();

            // Check for empty cells (they should be rendered as empty but not cause errors)
            const emptyCells = Array.from(document.querySelectorAll(container + ' tbody td')).filter(td => td.textContent.trim() === '');
            assert.ok(emptyCells.length > 0, 'Empty cells are rendered properly');

            drillDowner.destroy();
        });

        QUnit.test('Test with null values in data', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            // Create data with null values
            const nullData = [
                {p:null, c:"Rojo", w:"W1", rolls:10, quantity:100, unidades:"Kg", status:"pending"},
                {p:"Alpha", c:null, w:"W2", rolls:null, quantity:200, unidades:"m", status:"active"},
                {p:"Beta", c:"Verde", w:null, rolls:30, quantity:null, unidades:null, status:null}
            ];

            const drillDowner = new DrillDowner(container, nullData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status", "unidades"],
                totals: ["rolls", "quantity"]
            });

            // Check that the table renders without errors
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table renders with null values');

            // Expand to see all rows
            drillDowner.expandAll();

            // Check that totals are calculated correctly (ignoring nulls)
            const rollsTotal = nullData.reduce((sum, item) => sum + (item.rolls || 0), 0);
            const totalCells = document.querySelectorAll(container + ' tfoot td');

            let foundCorrectTotal = false;
            totalCells.forEach(cell => {
                // Look for the formatted total that matches our calculated total
                if (cell.textContent.includes(rollsTotal.toString())) {
                    foundCorrectTotal = true;
                }
            });

            assert.ok(foundCorrectTotal, 'Totals are calculated correctly with null values');

            drillDowner.destroy();
        });

        QUnit.test('Test with undefined values in data', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            // Create data with undefined values (by omitting properties)
            const undefinedData = [
                {p:"Alpha", rolls:10, quantity:100}, // missing c, w, status, unidades
                {p:"Beta", c:"Verde", rolls:20}, // missing w, quantity, status, unidades
                {c:"Azul", w:"W3", status:"pending"} // missing p, rolls, quantity, unidades
            ];

            const drillDowner = new DrillDowner(container, undefinedData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status", "unidades"],
                totals: ["rolls", "quantity"]
            });

            // Check that the table renders without errors
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table renders with undefined values');

            // Expand to see all rows
            drillDowner.expandAll();

            // Check that undefined values are handled gracefully
            const cells = document.querySelectorAll(container + ' tbody td');
            let hasEmptyCells = false;

            cells.forEach(cell => {
                if (cell.textContent.trim() === '') {
                    hasEmptyCells = true;
                }
            });

            assert.ok(hasEmptyCells, 'Undefined values are rendered as empty cells');

            drillDowner.destroy();
        });

        QUnit.test('Test with special characters in data', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            // Create data with special characters - avoiding problematic syntax
            const specialCharData = [
                {p:"HTML_SCRIPT_TAG", c:"Rojo", w:"W1", rolls:10, quantity:100, status:"HTML_BOLD_TAG"},
                {p:"Product & Name", c:"Color with Quote", w:"W2", rolls:20, quantity:200, status:"Status > Priority"},
                {p:"Line1 Line2", c:"Tab Character", w:"W3", rolls:30, quantity:300, status:"HTML_IMG_TAG"}
            ];

            const drillDowner = new DrillDowner(container, specialCharData, {
                groupOrder: ["p"],
                columns: ["c", "status"],
                totals: ["rolls"]
            });

            // Check that the table renders without errors
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table renders with special characters');

            // Check that special characters are handled properly
            const rowTexts = Array.from(document.querySelectorAll(container + ' tbody tr')).map(row => row.textContent);

            // Check for text representation of HTML
            const hasHtmlText = rowTexts.some(text => text.includes('HTML_'));
            assert.ok(hasHtmlText, 'HTML-like text is rendered properly');

            // Check for other special characters
            const hasAmpersand = rowTexts.some(text => text.includes('Product & Name'));
            assert.ok(hasAmpersand, 'Ampersands are rendered correctly');

            drillDowner.destroy();
        });

        QUnit.test('Test with duplicate values in grouping columns', function(assert) {
            const container = '#test-container';
            document.querySelector(container).innerHTML = '';

            // Create data with duplicate values in grouping columns
            const duplicateData = [
                {p:"Alpha", c:"Rojo", w:"W1", rolls:10, quantity:100, status:"pending"},
                {p:"Alpha", c:"Rojo", w:"W1", rolls:20, quantity:200, status:"active"}, // Duplicate of first row
                {p:"Alpha", c:"Rojo", w:"W2", rolls:30, quantity:300, status:"completed"},
                {p:"Beta", c:"Verde", w:"W1", rolls:40, quantity:400, status:"pending"},
                {p:"Beta", c:"Verde", w:"W1", rolls:50, quantity:500, status:"active"} // Duplicate of fourth row
            ];

            const drillDowner = new DrillDowner(container, duplicateData, {
                groupOrder: ["p", "c", "w"],
                columns: ["status"],
                totals: ["rolls"]
            });

            // Check that the table renders without errors
            assert.ok(document.querySelector(container + ' table.drillDowner_table'), 'Table renders with duplicate grouping values');

            // Expand all to see the full structure
            drillDowner.expandAll();

            // Count the number of rows at each level
            const level0Rows = document.querySelectorAll(container + ' tr[data-level="0"]').length;
            const level1Rows = document.querySelectorAll(container + ' tr[data-level="1"]').length;
            const level2Rows = document.querySelectorAll(container + ' tr[data-level="2"]').length;

            // We should have 2 unique products at level 0
            assert.equal(level0Rows, 2, 'Level 0 has 2 unique products');

            // We should have 2 unique colors at level 1
            assert.equal(level1Rows, 2, 'Level 1 has 2 unique colors');

            // We should have 3 unique warehouses at level 2
            assert.equal(level2Rows, 3, 'Level 2 has 3 unique warehouses');

            // Check that totals are summed correctly for duplicate groups
            // Alpha/Rojo/W1 should have rolls = 10 + 20 = 30
            const alphaRojoW1Total = duplicateData
                .filter(item => item.p === "Alpha" && item.c === "Rojo" && item.w === "W1")
                .reduce((sum, item) => sum + item.rolls, 0);

            assert.equal(alphaRojoW1Total, 30, 'Total for duplicate group is calculated correctly');

            drillDowner.destroy();
        });
    });

    // Start QUnit
    QUnit.start();
</script>
</body>
</html>
